{"ast":null,"code":"import _slicedToArray from \"D:/github/music-pwa-frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"D:/github/music-pwa-frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"D:/github/music-pwa-frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"D:/github/music-pwa-frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"D:/github/music-pwa-frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/github/music-pwa-frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/*\r\n  Copyright 2018 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { registerQuotaErrorCallback } from 'workbox-core/registerQuotaErrorCallback.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { CacheExpiration } from './CacheExpiration.js';\nimport './_version.js';\n/**\r\n * This plugin can be used in a `workbox-strategy` to regularly enforce a\r\n * limit on the age and / or the number of cached requests.\r\n *\r\n * It can only be used with `workbox-strategy` instances that have a\r\n * [custom `cacheName` property set](/web/tools/workbox/guides/configure-workbox#custom_cache_names_in_strategies).\r\n * In other words, it can't be used to expire entries in strategy that uses the\r\n * default runtime cache name.\r\n *\r\n * Whenever a cached response is used or updated, this plugin will look\r\n * at the associated cache and remove any old or extra responses.\r\n *\r\n * When using `maxAgeSeconds`, responses may be used *once* after expiring\r\n * because the expiration clean up will not have occurred until *after* the\r\n * cached response has been used. If the response has a \"Date\" header, then\r\n * a light weight expiration check is performed and the response will not be\r\n * used immediately.\r\n *\r\n * When using `maxEntries`, the entry least-recently requested will be removed\r\n * from the cache first.\r\n *\r\n * @memberof workbox-expiration\r\n */\nvar ExpirationPlugin = /*#__PURE__*/function () {\n  /**\r\n   * @param {ExpirationPluginOptions} config\r\n   * @param {number} [config.maxEntries] The maximum number of entries to cache.\r\n   * Entries used the least will be removed as the maximum is reached.\r\n   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\r\n   * it's treated as stale and removed.\r\n   * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)\r\n   * that will be used when calling `delete()` on the cache.\r\n   * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to\r\n   * automatic deletion if the available storage quota has been exceeded.\r\n   */\n  function ExpirationPlugin() {\n    var _this = this;\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, ExpirationPlugin);\n    /**\r\n     * A \"lifecycle\" callback that will be triggered automatically by the\r\n     * `workbox-strategies` handlers when a `Response` is about to be returned\r\n     * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to\r\n     * the handler. It allows the `Response` to be inspected for freshness and\r\n     * prevents it from being used if the `Response`'s `Date` header value is\r\n     * older than the configured `maxAgeSeconds`.\r\n     *\r\n     * @param {Object} options\r\n     * @param {string} options.cacheName Name of the cache the response is in.\r\n     * @param {Response} options.cachedResponse The `Response` object that's been\r\n     *     read from a cache and whose freshness should be checked.\r\n     * @return {Response} Either the `cachedResponse`, if it's\r\n     *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.\r\n     *\r\n     * @private\r\n     */\n    this.cachedResponseWillBeUsed = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {\n        var event, request, cacheName, cachedResponse, isFresh, cacheExpiration, updateTimestampDone;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              event = _ref.event, request = _ref.request, cacheName = _ref.cacheName, cachedResponse = _ref.cachedResponse;\n              if (cachedResponse) {\n                _context.next = 3;\n                break;\n              }\n              return _context.abrupt(\"return\", null);\n            case 3:\n              isFresh = _this._isResponseDateFresh(cachedResponse); // Expire entries to ensure that even if the expiration date has\n              // expired, it'll only be used once.\n              cacheExpiration = _this._getCacheExpiration(cacheName);\n              dontWaitFor(cacheExpiration.expireEntries());\n              // Update the metadata for the request URL to the current timestamp,\n              // but don't `await` it as we don't want to block the response.\n              updateTimestampDone = cacheExpiration.updateTimestamp(request.url);\n              if (event) {\n                try {\n                  event.waitUntil(updateTimestampDone);\n                } catch (error) {\n                  if (process.env.NODE_ENV !== 'production') {\n                    // The event may not be a fetch event; only log the URL if it is.\n                    if ('request' in event) {\n                      logger.warn(\"Unable to ensure service worker stays alive when \" + \"updating cache entry for \" + \"'\".concat(getFriendlyURL(event.request.url), \"'.\"));\n                    }\n                  }\n                }\n              }\n              return _context.abrupt(\"return\", isFresh ? cachedResponse : null);\n            case 9:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      return function (_x) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n    /**\r\n     * A \"lifecycle\" callback that will be triggered automatically by the\r\n     * `workbox-strategies` handlers when an entry is added to a cache.\r\n     *\r\n     * @param {Object} options\r\n     * @param {string} options.cacheName Name of the cache that was updated.\r\n     * @param {string} options.request The Request for the cached entry.\r\n     *\r\n     * @private\r\n     */\n    this.cacheDidUpdate = /*#__PURE__*/function () {\n      var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref3) {\n        var cacheName, request, cacheExpiration;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              cacheName = _ref3.cacheName, request = _ref3.request;\n              if (process.env.NODE_ENV !== 'production') {\n                assert.isType(cacheName, 'string', {\n                  moduleName: 'workbox-expiration',\n                  className: 'Plugin',\n                  funcName: 'cacheDidUpdate',\n                  paramName: 'cacheName'\n                });\n                assert.isInstance(request, Request, {\n                  moduleName: 'workbox-expiration',\n                  className: 'Plugin',\n                  funcName: 'cacheDidUpdate',\n                  paramName: 'request'\n                });\n              }\n              cacheExpiration = _this._getCacheExpiration(cacheName);\n              _context2.next = 5;\n              return cacheExpiration.updateTimestamp(request.url);\n            case 5:\n              _context2.next = 7;\n              return cacheExpiration.expireEntries();\n            case 7:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }));\n      return function (_x2) {\n        return _ref4.apply(this, arguments);\n      };\n    }();\n    if (process.env.NODE_ENV !== 'production') {\n      if (!(config.maxEntries || config.maxAgeSeconds)) {\n        throw new WorkboxError('max-entries-or-age-required', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor'\n        });\n      }\n      if (config.maxEntries) {\n        assert.isType(config.maxEntries, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor',\n          paramName: 'config.maxEntries'\n        });\n      }\n      if (config.maxAgeSeconds) {\n        assert.isType(config.maxAgeSeconds, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor',\n          paramName: 'config.maxAgeSeconds'\n        });\n      }\n    }\n    this._config = config;\n    this._maxAgeSeconds = config.maxAgeSeconds;\n    this._cacheExpirations = new Map();\n    if (config.purgeOnQuotaError) {\n      registerQuotaErrorCallback(function () {\n        return _this.deleteCacheAndMetadata();\n      });\n    }\n  }\n  /**\r\n   * A simple helper method to return a CacheExpiration instance for a given\r\n   * cache name.\r\n   *\r\n   * @param {string} cacheName\r\n   * @return {CacheExpiration}\r\n   *\r\n   * @private\r\n   */\n  _createClass(ExpirationPlugin, [{\n    key: \"_getCacheExpiration\",\n    value: function _getCacheExpiration(cacheName) {\n      if (cacheName === cacheNames.getRuntimeName()) {\n        throw new WorkboxError('expire-custom-caches-only');\n      }\n      var cacheExpiration = this._cacheExpirations.get(cacheName);\n      if (!cacheExpiration) {\n        cacheExpiration = new CacheExpiration(cacheName, this._config);\n        this._cacheExpirations.set(cacheName, cacheExpiration);\n      }\n      return cacheExpiration;\n    }\n    /**\r\n     * @param {Response} cachedResponse\r\n     * @return {boolean}\r\n     *\r\n     * @private\r\n     */\n  }, {\n    key: \"_isResponseDateFresh\",\n    value: function _isResponseDateFresh(cachedResponse) {\n      if (!this._maxAgeSeconds) {\n        // We aren't expiring by age, so return true, it's fresh\n        return true;\n      }\n      // Check if the 'date' header will suffice a quick expiration check.\n      // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for\n      // discussion.\n      var dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);\n      if (dateHeaderTimestamp === null) {\n        // Unable to parse date, so assume it's fresh.\n        return true;\n      }\n      // If we have a valid headerTime, then our response is fresh iff the\n      // headerTime plus maxAgeSeconds is greater than the current time.\n      var now = Date.now();\n      return dateHeaderTimestamp >= now - this._maxAgeSeconds * 1000;\n    }\n    /**\r\n     * This method will extract the data header and parse it into a useful\r\n     * value.\r\n     *\r\n     * @param {Response} cachedResponse\r\n     * @return {number|null}\r\n     *\r\n     * @private\r\n     */\n  }, {\n    key: \"_getDateHeaderTimestamp\",\n    value: function _getDateHeaderTimestamp(cachedResponse) {\n      if (!cachedResponse.headers.has('date')) {\n        return null;\n      }\n      var dateHeader = cachedResponse.headers.get('date');\n      var parsedDate = new Date(dateHeader);\n      var headerTime = parsedDate.getTime();\n      // If the Date header was invalid for some reason, parsedDate.getTime()\n      // will return NaN.\n      if (isNaN(headerTime)) {\n        return null;\n      }\n      return headerTime;\n    }\n    /**\r\n     * This is a helper method that performs two operations:\r\n     *\r\n     * - Deletes *all* the underlying Cache instances associated with this plugin\r\n     * instance, by calling caches.delete() on your behalf.\r\n     * - Deletes the metadata from IndexedDB used to keep track of expiration\r\n     * details for each Cache instance.\r\n     *\r\n     * When using cache expiration, calling this method is preferable to calling\r\n     * `caches.delete()` directly, since this will ensure that the IndexedDB\r\n     * metadata is also cleanly removed and open IndexedDB instances are deleted.\r\n     *\r\n     * Note that if you're *not* using cache expiration for a given cache, calling\r\n     * `caches.delete()` and passing in the cache's name should be sufficient.\r\n     * There is no Workbox-specific method needed for cleanup in that case.\r\n     */\n  }, {\n    key: \"deleteCacheAndMetadata\",\n    value: function () {\n      var _deleteCacheAndMetadata = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var _iterator, _step, _step$value, cacheName, cacheExpiration;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              // Do this one at a time instead of all at once via `Promise.all()` to\n              // reduce the chance of inconsistency if a promise rejects.\n              _iterator = _createForOfIteratorHelper(this._cacheExpirations);\n              _context3.prev = 1;\n              _iterator.s();\n            case 3:\n              if ((_step = _iterator.n()).done) {\n                _context3.next = 11;\n                break;\n              }\n              _step$value = _slicedToArray(_step.value, 2), cacheName = _step$value[0], cacheExpiration = _step$value[1];\n              _context3.next = 7;\n              return self.caches.delete(cacheName);\n            case 7:\n              _context3.next = 9;\n              return cacheExpiration.delete();\n            case 9:\n              _context3.next = 3;\n              break;\n            case 11:\n              _context3.next = 16;\n              break;\n            case 13:\n              _context3.prev = 13;\n              _context3.t0 = _context3[\"catch\"](1);\n              _iterator.e(_context3.t0);\n            case 16:\n              _context3.prev = 16;\n              _iterator.f();\n              return _context3.finish(16);\n            case 19:\n              // Reset this._cacheExpirations to its initial state.\n              this._cacheExpirations = new Map();\n            case 20:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[1, 13, 16, 19]]);\n      }));\n      function deleteCacheAndMetadata() {\n        return _deleteCacheAndMetadata.apply(this, arguments);\n      }\n      return deleteCacheAndMetadata;\n    }()\n  }]);\n  return ExpirationPlugin;\n}();\nexport { ExpirationPlugin };","map":{"version":3,"names":["assert","cacheNames","dontWaitFor","getFriendlyURL","logger","registerQuotaErrorCallback","WorkboxError","CacheExpiration","ExpirationPlugin","config","cachedResponseWillBeUsed","event","request","cacheName","cachedResponse","isFresh","_isResponseDateFresh","cacheExpiration","_getCacheExpiration","expireEntries","updateTimestampDone","updateTimestamp","url","waitUntil","error","process","env","NODE_ENV","warn","cacheDidUpdate","isType","moduleName","className","funcName","paramName","isInstance","Request","maxEntries","maxAgeSeconds","_config","_maxAgeSeconds","_cacheExpirations","Map","purgeOnQuotaError","deleteCacheAndMetadata","getRuntimeName","get","set","dateHeaderTimestamp","_getDateHeaderTimestamp","now","Date","headers","has","dateHeader","parsedDate","headerTime","getTime","isNaN","self","caches","delete"],"sources":["D:/github/music-pwa-frontend/node_modules/workbox-expiration/ExpirationPlugin.js"],"sourcesContent":["/*\r\n  Copyright 2018 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { assert } from 'workbox-core/_private/assert.js';\r\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\r\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\r\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\r\nimport { logger } from 'workbox-core/_private/logger.js';\r\nimport { registerQuotaErrorCallback } from 'workbox-core/registerQuotaErrorCallback.js';\r\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\r\nimport { CacheExpiration } from './CacheExpiration.js';\r\nimport './_version.js';\r\n/**\r\n * This plugin can be used in a `workbox-strategy` to regularly enforce a\r\n * limit on the age and / or the number of cached requests.\r\n *\r\n * It can only be used with `workbox-strategy` instances that have a\r\n * [custom `cacheName` property set](/web/tools/workbox/guides/configure-workbox#custom_cache_names_in_strategies).\r\n * In other words, it can't be used to expire entries in strategy that uses the\r\n * default runtime cache name.\r\n *\r\n * Whenever a cached response is used or updated, this plugin will look\r\n * at the associated cache and remove any old or extra responses.\r\n *\r\n * When using `maxAgeSeconds`, responses may be used *once* after expiring\r\n * because the expiration clean up will not have occurred until *after* the\r\n * cached response has been used. If the response has a \"Date\" header, then\r\n * a light weight expiration check is performed and the response will not be\r\n * used immediately.\r\n *\r\n * When using `maxEntries`, the entry least-recently requested will be removed\r\n * from the cache first.\r\n *\r\n * @memberof workbox-expiration\r\n */\r\nclass ExpirationPlugin {\r\n    /**\r\n     * @param {ExpirationPluginOptions} config\r\n     * @param {number} [config.maxEntries] The maximum number of entries to cache.\r\n     * Entries used the least will be removed as the maximum is reached.\r\n     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\r\n     * it's treated as stale and removed.\r\n     * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)\r\n     * that will be used when calling `delete()` on the cache.\r\n     * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to\r\n     * automatic deletion if the available storage quota has been exceeded.\r\n     */\r\n    constructor(config = {}) {\r\n        /**\r\n         * A \"lifecycle\" callback that will be triggered automatically by the\r\n         * `workbox-strategies` handlers when a `Response` is about to be returned\r\n         * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to\r\n         * the handler. It allows the `Response` to be inspected for freshness and\r\n         * prevents it from being used if the `Response`'s `Date` header value is\r\n         * older than the configured `maxAgeSeconds`.\r\n         *\r\n         * @param {Object} options\r\n         * @param {string} options.cacheName Name of the cache the response is in.\r\n         * @param {Response} options.cachedResponse The `Response` object that's been\r\n         *     read from a cache and whose freshness should be checked.\r\n         * @return {Response} Either the `cachedResponse`, if it's\r\n         *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.\r\n         *\r\n         * @private\r\n         */\r\n        this.cachedResponseWillBeUsed = async ({ event, request, cacheName, cachedResponse, }) => {\r\n            if (!cachedResponse) {\r\n                return null;\r\n            }\r\n            const isFresh = this._isResponseDateFresh(cachedResponse);\r\n            // Expire entries to ensure that even if the expiration date has\r\n            // expired, it'll only be used once.\r\n            const cacheExpiration = this._getCacheExpiration(cacheName);\r\n            dontWaitFor(cacheExpiration.expireEntries());\r\n            // Update the metadata for the request URL to the current timestamp,\r\n            // but don't `await` it as we don't want to block the response.\r\n            const updateTimestampDone = cacheExpiration.updateTimestamp(request.url);\r\n            if (event) {\r\n                try {\r\n                    event.waitUntil(updateTimestampDone);\r\n                }\r\n                catch (error) {\r\n                    if (process.env.NODE_ENV !== 'production') {\r\n                        // The event may not be a fetch event; only log the URL if it is.\r\n                        if ('request' in event) {\r\n                            logger.warn(`Unable to ensure service worker stays alive when ` +\r\n                                `updating cache entry for ` +\r\n                                `'${getFriendlyURL(event.request.url)}'.`);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return isFresh ? cachedResponse : null;\r\n        };\r\n        /**\r\n         * A \"lifecycle\" callback that will be triggered automatically by the\r\n         * `workbox-strategies` handlers when an entry is added to a cache.\r\n         *\r\n         * @param {Object} options\r\n         * @param {string} options.cacheName Name of the cache that was updated.\r\n         * @param {string} options.request The Request for the cached entry.\r\n         *\r\n         * @private\r\n         */\r\n        this.cacheDidUpdate = async ({ cacheName, request, }) => {\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                assert.isType(cacheName, 'string', {\r\n                    moduleName: 'workbox-expiration',\r\n                    className: 'Plugin',\r\n                    funcName: 'cacheDidUpdate',\r\n                    paramName: 'cacheName',\r\n                });\r\n                assert.isInstance(request, Request, {\r\n                    moduleName: 'workbox-expiration',\r\n                    className: 'Plugin',\r\n                    funcName: 'cacheDidUpdate',\r\n                    paramName: 'request',\r\n                });\r\n            }\r\n            const cacheExpiration = this._getCacheExpiration(cacheName);\r\n            await cacheExpiration.updateTimestamp(request.url);\r\n            await cacheExpiration.expireEntries();\r\n        };\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (!(config.maxEntries || config.maxAgeSeconds)) {\r\n                throw new WorkboxError('max-entries-or-age-required', {\r\n                    moduleName: 'workbox-expiration',\r\n                    className: 'Plugin',\r\n                    funcName: 'constructor',\r\n                });\r\n            }\r\n            if (config.maxEntries) {\r\n                assert.isType(config.maxEntries, 'number', {\r\n                    moduleName: 'workbox-expiration',\r\n                    className: 'Plugin',\r\n                    funcName: 'constructor',\r\n                    paramName: 'config.maxEntries',\r\n                });\r\n            }\r\n            if (config.maxAgeSeconds) {\r\n                assert.isType(config.maxAgeSeconds, 'number', {\r\n                    moduleName: 'workbox-expiration',\r\n                    className: 'Plugin',\r\n                    funcName: 'constructor',\r\n                    paramName: 'config.maxAgeSeconds',\r\n                });\r\n            }\r\n        }\r\n        this._config = config;\r\n        this._maxAgeSeconds = config.maxAgeSeconds;\r\n        this._cacheExpirations = new Map();\r\n        if (config.purgeOnQuotaError) {\r\n            registerQuotaErrorCallback(() => this.deleteCacheAndMetadata());\r\n        }\r\n    }\r\n    /**\r\n     * A simple helper method to return a CacheExpiration instance for a given\r\n     * cache name.\r\n     *\r\n     * @param {string} cacheName\r\n     * @return {CacheExpiration}\r\n     *\r\n     * @private\r\n     */\r\n    _getCacheExpiration(cacheName) {\r\n        if (cacheName === cacheNames.getRuntimeName()) {\r\n            throw new WorkboxError('expire-custom-caches-only');\r\n        }\r\n        let cacheExpiration = this._cacheExpirations.get(cacheName);\r\n        if (!cacheExpiration) {\r\n            cacheExpiration = new CacheExpiration(cacheName, this._config);\r\n            this._cacheExpirations.set(cacheName, cacheExpiration);\r\n        }\r\n        return cacheExpiration;\r\n    }\r\n    /**\r\n     * @param {Response} cachedResponse\r\n     * @return {boolean}\r\n     *\r\n     * @private\r\n     */\r\n    _isResponseDateFresh(cachedResponse) {\r\n        if (!this._maxAgeSeconds) {\r\n            // We aren't expiring by age, so return true, it's fresh\r\n            return true;\r\n        }\r\n        // Check if the 'date' header will suffice a quick expiration check.\r\n        // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for\r\n        // discussion.\r\n        const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);\r\n        if (dateHeaderTimestamp === null) {\r\n            // Unable to parse date, so assume it's fresh.\r\n            return true;\r\n        }\r\n        // If we have a valid headerTime, then our response is fresh iff the\r\n        // headerTime plus maxAgeSeconds is greater than the current time.\r\n        const now = Date.now();\r\n        return dateHeaderTimestamp >= now - this._maxAgeSeconds * 1000;\r\n    }\r\n    /**\r\n     * This method will extract the data header and parse it into a useful\r\n     * value.\r\n     *\r\n     * @param {Response} cachedResponse\r\n     * @return {number|null}\r\n     *\r\n     * @private\r\n     */\r\n    _getDateHeaderTimestamp(cachedResponse) {\r\n        if (!cachedResponse.headers.has('date')) {\r\n            return null;\r\n        }\r\n        const dateHeader = cachedResponse.headers.get('date');\r\n        const parsedDate = new Date(dateHeader);\r\n        const headerTime = parsedDate.getTime();\r\n        // If the Date header was invalid for some reason, parsedDate.getTime()\r\n        // will return NaN.\r\n        if (isNaN(headerTime)) {\r\n            return null;\r\n        }\r\n        return headerTime;\r\n    }\r\n    /**\r\n     * This is a helper method that performs two operations:\r\n     *\r\n     * - Deletes *all* the underlying Cache instances associated with this plugin\r\n     * instance, by calling caches.delete() on your behalf.\r\n     * - Deletes the metadata from IndexedDB used to keep track of expiration\r\n     * details for each Cache instance.\r\n     *\r\n     * When using cache expiration, calling this method is preferable to calling\r\n     * `caches.delete()` directly, since this will ensure that the IndexedDB\r\n     * metadata is also cleanly removed and open IndexedDB instances are deleted.\r\n     *\r\n     * Note that if you're *not* using cache expiration for a given cache, calling\r\n     * `caches.delete()` and passing in the cache's name should be sufficient.\r\n     * There is no Workbox-specific method needed for cleanup in that case.\r\n     */\r\n    async deleteCacheAndMetadata() {\r\n        // Do this one at a time instead of all at once via `Promise.all()` to\r\n        // reduce the chance of inconsistency if a promise rejects.\r\n        for (const [cacheName, cacheExpiration] of this._cacheExpirations) {\r\n            await self.caches.delete(cacheName);\r\n            await cacheExpiration.delete();\r\n        }\r\n        // Reset this._cacheExpirations to its initial state.\r\n        this._cacheExpirations = new Map();\r\n    }\r\n}\r\nexport { ExpirationPlugin };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}