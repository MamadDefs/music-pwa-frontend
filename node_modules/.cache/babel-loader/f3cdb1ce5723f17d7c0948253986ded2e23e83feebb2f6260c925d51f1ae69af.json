{"ast":null,"code":"import _regeneratorRuntime from \"D:/github/music-pwa-frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _createForOfIteratorHelper from \"D:/github/music-pwa-frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"D:/github/music-pwa-frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _slicedToArray from \"D:/github/music-pwa-frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"D:/github/music-pwa-frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/github/music-pwa-frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/*\r\n  Copyright 2020 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { StrategyHandler } from './StrategyHandler.js';\nimport './_version.js';\n/**\r\n * An abstract base class that all other strategy classes must extend from:\r\n *\r\n * @memberof workbox-strategies\r\n */\nvar Strategy = /*#__PURE__*/function () {\n  /**\r\n   * Creates a new instance of the strategy and sets all documented option\r\n   * properties as public instance properties.\r\n   *\r\n   * Note: if a custom strategy class extends the base Strategy class and does\r\n   * not need more than these properties, it does not need to define its own\r\n   * constructor.\r\n   *\r\n   * @param {Object} [options]\r\n   * @param {string} [options.cacheName] Cache name to store and retrieve\r\n   * requests. Defaults to the cache names provided by\r\n   * {@link workbox-core.cacheNames}.\r\n   * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\r\n   * to use in conjunction with this caching strategy.\r\n   * @param {Object} [options.fetchOptions] Values passed along to the\r\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\r\n   * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\r\n   * `fetch()` requests made by this strategy.\r\n   * @param {Object} [options.matchOptions] The\r\n   * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\r\n   * for any `cache.match()` or `cache.put()` calls made by this strategy.\r\n   */\n  function Strategy() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, Strategy);\n    /**\r\n     * Cache name to store and retrieve\r\n     * requests. Defaults to the cache names provided by\r\n     * {@link workbox-core.cacheNames}.\r\n     *\r\n     * @type {string}\r\n     */\n    this.cacheName = cacheNames.getRuntimeName(options.cacheName);\n    /**\r\n     * The list\r\n     * [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\r\n     * used by this strategy.\r\n     *\r\n     * @type {Array<Object>}\r\n     */\n    this.plugins = options.plugins || [];\n    /**\r\n     * Values passed along to the\r\n     * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}\r\n     * of all fetch() requests made by this strategy.\r\n     *\r\n     * @type {Object}\r\n     */\n    this.fetchOptions = options.fetchOptions;\n    /**\r\n     * The\r\n     * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\r\n     * for any `cache.match()` or `cache.put()` calls made by this strategy.\r\n     *\r\n     * @type {Object}\r\n     */\n    this.matchOptions = options.matchOptions;\n  }\n  /**\r\n   * Perform a request strategy and returns a `Promise` that will resolve with\r\n   * a `Response`, invoking all relevant plugin callbacks.\r\n   *\r\n   * When a strategy instance is registered with a Workbox\r\n   * {@link workbox-routing.Route}, this method is automatically\r\n   * called when the route matches.\r\n   *\r\n   * Alternatively, this method can be used in a standalone `FetchEvent`\r\n   * listener by passing it to `event.respondWith()`.\r\n   *\r\n   * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\r\n   *     properties listed below.\r\n   * @param {Request|string} options.request A request to run this strategy for.\r\n   * @param {ExtendableEvent} options.event The event associated with the\r\n   *     request.\r\n   * @param {URL} [options.url]\r\n   * @param {*} [options.params]\r\n   */\n  _createClass(Strategy, [{\n    key: \"handle\",\n    value: function handle(options) {\n      var _this$handleAll = this.handleAll(options),\n        _this$handleAll2 = _slicedToArray(_this$handleAll, 1),\n        responseDone = _this$handleAll2[0];\n      return responseDone;\n    }\n    /**\r\n     * Similar to {@link workbox-strategies.Strategy~handle}, but\r\n     * instead of just returning a `Promise` that resolves to a `Response` it\r\n     * it will return an tuple of `[response, done]` promises, where the former\r\n     * (`response`) is equivalent to what `handle()` returns, and the latter is a\r\n     * Promise that will resolve once any promises that were added to\r\n     * `event.waitUntil()` as part of performing the strategy have completed.\r\n     *\r\n     * You can await the `done` promise to ensure any extra work performed by\r\n     * the strategy (usually caching responses) completes successfully.\r\n     *\r\n     * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\r\n     *     properties listed below.\r\n     * @param {Request|string} options.request A request to run this strategy for.\r\n     * @param {ExtendableEvent} options.event The event associated with the\r\n     *     request.\r\n     * @param {URL} [options.url]\r\n     * @param {*} [options.params]\r\n     * @return {Array<Promise>} A tuple of [response, done]\r\n     *     promises that can be used to determine when the response resolves as\r\n     *     well as when the handler has completed all its work.\r\n     */\n  }, {\n    key: \"handleAll\",\n    value: function handleAll(options) {\n      // Allow for flexible options to be passed.\n      if (options instanceof FetchEvent) {\n        options = {\n          event: options,\n          request: options.request\n        };\n      }\n      var event = options.event;\n      var request = typeof options.request === 'string' ? new Request(options.request) : options.request;\n      var params = 'params' in options ? options.params : undefined;\n      var handler = new StrategyHandler(this, {\n        event: event,\n        request: request,\n        params: params\n      });\n      var responseDone = this._getResponse(handler, request, event);\n      var handlerDone = this._awaitComplete(responseDone, handler, request, event);\n      // Return an array of promises, suitable for use with Promise.all().\n      return [responseDone, handlerDone];\n    }\n  }, {\n    key: \"_getResponse\",\n    value: function () {\n      var _getResponse2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(handler, request, event) {\n        var response, _iterator, _step, callback, _iterator2, _step2, _callback;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return handler.runCallbacks('handlerWillStart', {\n                event: event,\n                request: request\n              });\n            case 2:\n              response = undefined;\n              _context.prev = 3;\n              _context.next = 6;\n              return this._handle(request, handler);\n            case 6:\n              response = _context.sent;\n              if (!(!response || response.type === 'error')) {\n                _context.next = 9;\n                break;\n              }\n              throw new WorkboxError('no-response', {\n                url: request.url\n              });\n            case 9:\n              _context.next = 39;\n              break;\n            case 11:\n              _context.prev = 11;\n              _context.t0 = _context[\"catch\"](3);\n              if (!(_context.t0 instanceof Error)) {\n                _context.next = 34;\n                break;\n              }\n              _iterator = _createForOfIteratorHelper(handler.iterateCallbacks('handlerDidError'));\n              _context.prev = 15;\n              _iterator.s();\n            case 17:\n              if ((_step = _iterator.n()).done) {\n                _context.next = 26;\n                break;\n              }\n              callback = _step.value;\n              _context.next = 21;\n              return callback({\n                error: _context.t0,\n                event: event,\n                request: request\n              });\n            case 21:\n              response = _context.sent;\n              if (!response) {\n                _context.next = 24;\n                break;\n              }\n              return _context.abrupt(\"break\", 26);\n            case 24:\n              _context.next = 17;\n              break;\n            case 26:\n              _context.next = 31;\n              break;\n            case 28:\n              _context.prev = 28;\n              _context.t1 = _context[\"catch\"](15);\n              _iterator.e(_context.t1);\n            case 31:\n              _context.prev = 31;\n              _iterator.f();\n              return _context.finish(31);\n            case 34:\n              if (response) {\n                _context.next = 38;\n                break;\n              }\n              throw _context.t0;\n            case 38:\n              if (process.env.NODE_ENV !== 'production') {\n                logger.log(\"While responding to '\".concat(getFriendlyURL(request.url), \"', \") + \"an \".concat(_context.t0 instanceof Error ? _context.t0.toString() : '', \" error occurred. Using a fallback response provided by \") + \"a handlerDidError plugin.\");\n              }\n            case 39:\n              _iterator2 = _createForOfIteratorHelper(handler.iterateCallbacks('handlerWillRespond'));\n              _context.prev = 40;\n              _iterator2.s();\n            case 42:\n              if ((_step2 = _iterator2.n()).done) {\n                _context.next = 49;\n                break;\n              }\n              _callback = _step2.value;\n              _context.next = 46;\n              return _callback({\n                event: event,\n                request: request,\n                response: response\n              });\n            case 46:\n              response = _context.sent;\n            case 47:\n              _context.next = 42;\n              break;\n            case 49:\n              _context.next = 54;\n              break;\n            case 51:\n              _context.prev = 51;\n              _context.t2 = _context[\"catch\"](40);\n              _iterator2.e(_context.t2);\n            case 54:\n              _context.prev = 54;\n              _iterator2.f();\n              return _context.finish(54);\n            case 57:\n              return _context.abrupt(\"return\", response);\n            case 58:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[3, 11], [15, 28, 31, 34], [40, 51, 54, 57]]);\n      }));\n      function _getResponse(_x, _x2, _x3) {\n        return _getResponse2.apply(this, arguments);\n      }\n      return _getResponse;\n    }()\n  }, {\n    key: \"_awaitComplete\",\n    value: function () {\n      var _awaitComplete2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(responseDone, handler, request, event) {\n        var response, error;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.prev = 0;\n              _context2.next = 3;\n              return responseDone;\n            case 3:\n              response = _context2.sent;\n              _context2.next = 8;\n              break;\n            case 6:\n              _context2.prev = 6;\n              _context2.t0 = _context2[\"catch\"](0);\n            case 8:\n              _context2.prev = 8;\n              _context2.next = 11;\n              return handler.runCallbacks('handlerDidRespond', {\n                event: event,\n                request: request,\n                response: response\n              });\n            case 11:\n              _context2.next = 13;\n              return handler.doneWaiting();\n            case 13:\n              _context2.next = 18;\n              break;\n            case 15:\n              _context2.prev = 15;\n              _context2.t1 = _context2[\"catch\"](8);\n              if (_context2.t1 instanceof Error) {\n                error = _context2.t1;\n              }\n            case 18:\n              _context2.next = 20;\n              return handler.runCallbacks('handlerDidComplete', {\n                event: event,\n                request: request,\n                response: response,\n                error: error\n              });\n            case 20:\n              handler.destroy();\n              if (!error) {\n                _context2.next = 23;\n                break;\n              }\n              throw error;\n            case 23:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, null, [[0, 6], [8, 15]]);\n      }));\n      function _awaitComplete(_x4, _x5, _x6, _x7) {\n        return _awaitComplete2.apply(this, arguments);\n      }\n      return _awaitComplete;\n    }()\n  }]);\n  return Strategy;\n}();\nexport { Strategy };\n/**\r\n * Classes extending the `Strategy` based class should implement this method,\r\n * and leverage the {@link workbox-strategies.StrategyHandler}\r\n * arg to perform all fetching and cache logic, which will ensure all relevant\r\n * cache, cache options, fetch options and plugins are used (per the current\r\n * strategy instance).\r\n *\r\n * @name _handle\r\n * @instance\r\n * @abstract\r\n * @function\r\n * @param {Request} request\r\n * @param {workbox-strategies.StrategyHandler} handler\r\n * @return {Promise<Response>}\r\n *\r\n * @memberof workbox-strategies.Strategy\r\n */","map":{"version":3,"names":["cacheNames","WorkboxError","logger","getFriendlyURL","StrategyHandler","Strategy","options","cacheName","getRuntimeName","plugins","fetchOptions","matchOptions","handleAll","responseDone","FetchEvent","event","request","Request","params","undefined","handler","_getResponse","handlerDone","_awaitComplete","runCallbacks","response","_handle","type","url","Error","iterateCallbacks","callback","error","process","env","NODE_ENV","log","toString","doneWaiting","destroy"],"sources":["D:/github/music-pwa-frontend/node_modules/workbox-strategies/Strategy.js"],"sourcesContent":["/*\r\n  Copyright 2020 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\r\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\r\nimport { logger } from 'workbox-core/_private/logger.js';\r\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\r\nimport { StrategyHandler } from './StrategyHandler.js';\r\nimport './_version.js';\r\n/**\r\n * An abstract base class that all other strategy classes must extend from:\r\n *\r\n * @memberof workbox-strategies\r\n */\r\nclass Strategy {\r\n    /**\r\n     * Creates a new instance of the strategy and sets all documented option\r\n     * properties as public instance properties.\r\n     *\r\n     * Note: if a custom strategy class extends the base Strategy class and does\r\n     * not need more than these properties, it does not need to define its own\r\n     * constructor.\r\n     *\r\n     * @param {Object} [options]\r\n     * @param {string} [options.cacheName] Cache name to store and retrieve\r\n     * requests. Defaults to the cache names provided by\r\n     * {@link workbox-core.cacheNames}.\r\n     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\r\n     * to use in conjunction with this caching strategy.\r\n     * @param {Object} [options.fetchOptions] Values passed along to the\r\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\r\n     * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\r\n     * `fetch()` requests made by this strategy.\r\n     * @param {Object} [options.matchOptions] The\r\n     * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\r\n     * for any `cache.match()` or `cache.put()` calls made by this strategy.\r\n     */\r\n    constructor(options = {}) {\r\n        /**\r\n         * Cache name to store and retrieve\r\n         * requests. Defaults to the cache names provided by\r\n         * {@link workbox-core.cacheNames}.\r\n         *\r\n         * @type {string}\r\n         */\r\n        this.cacheName = cacheNames.getRuntimeName(options.cacheName);\r\n        /**\r\n         * The list\r\n         * [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\r\n         * used by this strategy.\r\n         *\r\n         * @type {Array<Object>}\r\n         */\r\n        this.plugins = options.plugins || [];\r\n        /**\r\n         * Values passed along to the\r\n         * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}\r\n         * of all fetch() requests made by this strategy.\r\n         *\r\n         * @type {Object}\r\n         */\r\n        this.fetchOptions = options.fetchOptions;\r\n        /**\r\n         * The\r\n         * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\r\n         * for any `cache.match()` or `cache.put()` calls made by this strategy.\r\n         *\r\n         * @type {Object}\r\n         */\r\n        this.matchOptions = options.matchOptions;\r\n    }\r\n    /**\r\n     * Perform a request strategy and returns a `Promise` that will resolve with\r\n     * a `Response`, invoking all relevant plugin callbacks.\r\n     *\r\n     * When a strategy instance is registered with a Workbox\r\n     * {@link workbox-routing.Route}, this method is automatically\r\n     * called when the route matches.\r\n     *\r\n     * Alternatively, this method can be used in a standalone `FetchEvent`\r\n     * listener by passing it to `event.respondWith()`.\r\n     *\r\n     * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\r\n     *     properties listed below.\r\n     * @param {Request|string} options.request A request to run this strategy for.\r\n     * @param {ExtendableEvent} options.event The event associated with the\r\n     *     request.\r\n     * @param {URL} [options.url]\r\n     * @param {*} [options.params]\r\n     */\r\n    handle(options) {\r\n        const [responseDone] = this.handleAll(options);\r\n        return responseDone;\r\n    }\r\n    /**\r\n     * Similar to {@link workbox-strategies.Strategy~handle}, but\r\n     * instead of just returning a `Promise` that resolves to a `Response` it\r\n     * it will return an tuple of `[response, done]` promises, where the former\r\n     * (`response`) is equivalent to what `handle()` returns, and the latter is a\r\n     * Promise that will resolve once any promises that were added to\r\n     * `event.waitUntil()` as part of performing the strategy have completed.\r\n     *\r\n     * You can await the `done` promise to ensure any extra work performed by\r\n     * the strategy (usually caching responses) completes successfully.\r\n     *\r\n     * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\r\n     *     properties listed below.\r\n     * @param {Request|string} options.request A request to run this strategy for.\r\n     * @param {ExtendableEvent} options.event The event associated with the\r\n     *     request.\r\n     * @param {URL} [options.url]\r\n     * @param {*} [options.params]\r\n     * @return {Array<Promise>} A tuple of [response, done]\r\n     *     promises that can be used to determine when the response resolves as\r\n     *     well as when the handler has completed all its work.\r\n     */\r\n    handleAll(options) {\r\n        // Allow for flexible options to be passed.\r\n        if (options instanceof FetchEvent) {\r\n            options = {\r\n                event: options,\r\n                request: options.request,\r\n            };\r\n        }\r\n        const event = options.event;\r\n        const request = typeof options.request === 'string'\r\n            ? new Request(options.request)\r\n            : options.request;\r\n        const params = 'params' in options ? options.params : undefined;\r\n        const handler = new StrategyHandler(this, { event, request, params });\r\n        const responseDone = this._getResponse(handler, request, event);\r\n        const handlerDone = this._awaitComplete(responseDone, handler, request, event);\r\n        // Return an array of promises, suitable for use with Promise.all().\r\n        return [responseDone, handlerDone];\r\n    }\r\n    async _getResponse(handler, request, event) {\r\n        await handler.runCallbacks('handlerWillStart', { event, request });\r\n        let response = undefined;\r\n        try {\r\n            response = await this._handle(request, handler);\r\n            // The \"official\" Strategy subclasses all throw this error automatically,\r\n            // but in case a third-party Strategy doesn't, ensure that we have a\r\n            // consistent failure when there's no response or an error response.\r\n            if (!response || response.type === 'error') {\r\n                throw new WorkboxError('no-response', { url: request.url });\r\n            }\r\n        }\r\n        catch (error) {\r\n            if (error instanceof Error) {\r\n                for (const callback of handler.iterateCallbacks('handlerDidError')) {\r\n                    response = await callback({ error, event, request });\r\n                    if (response) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (!response) {\r\n                throw error;\r\n            }\r\n            else if (process.env.NODE_ENV !== 'production') {\r\n                logger.log(`While responding to '${getFriendlyURL(request.url)}', ` +\r\n                    `an ${error instanceof Error ? error.toString() : ''} error occurred. Using a fallback response provided by ` +\r\n                    `a handlerDidError plugin.`);\r\n            }\r\n        }\r\n        for (const callback of handler.iterateCallbacks('handlerWillRespond')) {\r\n            response = await callback({ event, request, response });\r\n        }\r\n        return response;\r\n    }\r\n    async _awaitComplete(responseDone, handler, request, event) {\r\n        let response;\r\n        let error;\r\n        try {\r\n            response = await responseDone;\r\n        }\r\n        catch (error) {\r\n            // Ignore errors, as response errors should be caught via the `response`\r\n            // promise above. The `done` promise will only throw for errors in\r\n            // promises passed to `handler.waitUntil()`.\r\n        }\r\n        try {\r\n            await handler.runCallbacks('handlerDidRespond', {\r\n                event,\r\n                request,\r\n                response,\r\n            });\r\n            await handler.doneWaiting();\r\n        }\r\n        catch (waitUntilError) {\r\n            if (waitUntilError instanceof Error) {\r\n                error = waitUntilError;\r\n            }\r\n        }\r\n        await handler.runCallbacks('handlerDidComplete', {\r\n            event,\r\n            request,\r\n            response,\r\n            error: error,\r\n        });\r\n        handler.destroy();\r\n        if (error) {\r\n            throw error;\r\n        }\r\n    }\r\n}\r\nexport { Strategy };\r\n/**\r\n * Classes extending the `Strategy` based class should implement this method,\r\n * and leverage the {@link workbox-strategies.StrategyHandler}\r\n * arg to perform all fetching and cache logic, which will ensure all relevant\r\n * cache, cache options, fetch options and plugins are used (per the current\r\n * strategy instance).\r\n *\r\n * @name _handle\r\n * @instance\r\n * @abstract\r\n * @function\r\n * @param {Request} request\r\n * @param {workbox-strategies.StrategyHandler} handler\r\n * @return {Promise<Response>}\r\n *\r\n * @memberof workbox-strategies.Strategy\r\n */\r\n"],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,UAAU,QAAQ,qCAAqC;AAChE,SAASC,YAAY,QAAQ,uCAAuC;AACpE,SAASC,MAAM,QAAQ,iCAAiC;AACxD,SAASC,cAAc,QAAQ,yCAAyC;AACxE,SAASC,eAAe,QAAQ,sBAAsB;AACtD,OAAO,eAAe;AACtB;AACA;AACA;AACA;AACA;AAJA,IAKMC,QAAQ;EACV;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,oBAA0B;IAAA,IAAdC,OAAO,uEAAG,CAAC,CAAC;IAAA;IACpB;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,SAAS,GAAGP,UAAU,CAACQ,cAAc,CAACF,OAAO,CAACC,SAAS,CAAC;IAC7D;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACE,OAAO,GAAGH,OAAO,CAACG,OAAO,IAAI,EAAE;IACpC;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,YAAY,GAAGJ,OAAO,CAACI,YAAY;IACxC;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,YAAY,GAAGL,OAAO,CAACK,YAAY;EAC5C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAlBI;IAAA;IAAA,OAmBA,gBAAOL,OAAO,EAAE;MACZ,sBAAuB,IAAI,CAACM,SAAS,CAACN,OAAO,CAAC;QAAA;QAAvCO,YAAY;MACnB,OAAOA,YAAY;IACvB;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EArBI;IAAA;IAAA,OAsBA,mBAAUP,OAAO,EAAE;MACf;MACA,IAAIA,OAAO,YAAYQ,UAAU,EAAE;QAC/BR,OAAO,GAAG;UACNS,KAAK,EAAET,O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"},"metadata":{},"sourceType":"module","externalDependencies":[]}