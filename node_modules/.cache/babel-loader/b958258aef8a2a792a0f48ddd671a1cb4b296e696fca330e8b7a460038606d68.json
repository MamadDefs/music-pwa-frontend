{"ast":null,"code":"import _createForOfIteratorHelper from \"D:/github/music-pwa-frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"D:/github/music-pwa-frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"D:/github/music-pwa-frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _construct from \"D:/github/music-pwa-frontend/node_modules/@babel/runtime/helpers/esm/construct.js\";\nimport _toConsumableArray from \"D:/github/music-pwa-frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"D:/github/music-pwa-frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/github/music-pwa-frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/*\r\n  Copyright 2018 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { defaultMethod } from './utils/constants.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { normalizeHandler } from './utils/normalizeHandler.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport './_version.js';\n/**\r\n * The Router can be used to process a `FetchEvent` using one or more\r\n * {@link workbox-routing.Route}, responding with a `Response` if\r\n * a matching route exists.\r\n *\r\n * If no route matches a given a request, the Router will use a \"default\"\r\n * handler if one is defined.\r\n *\r\n * Should the matching Route throw an error, the Router will use a \"catch\"\r\n * handler if one is defined to gracefully deal with issues and respond with a\r\n * Request.\r\n *\r\n * If a request matches multiple routes, the **earliest** registered route will\r\n * be used to respond to the request.\r\n *\r\n * @memberof workbox-routing\r\n */\nvar Router = /*#__PURE__*/function () {\n  /**\r\n   * Initializes a new Router.\r\n   */\n  function Router() {\n    _classCallCheck(this, Router);\n    this._routes = new Map();\n    this._defaultHandlerMap = new Map();\n  }\n  /**\r\n   * @return {Map<string, Array<workbox-routing.Route>>} routes A `Map` of HTTP\r\n   * method name ('GET', etc.) to an array of all the corresponding `Route`\r\n   * instances that are registered.\r\n   */\n  _createClass(Router, [{\n    key: \"routes\",\n    get: function get() {\n      return this._routes;\n    }\n    /**\r\n     * Adds a fetch event listener to respond to events when a route matches\r\n     * the event's request.\r\n     */\n  }, {\n    key: \"addFetchListener\",\n    value: function addFetchListener() {\n      var _this = this;\n      // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n      self.addEventListener('fetch', function (event) {\n        var request = event.request;\n        var responsePromise = _this.handleRequest({\n          request: request,\n          event: event\n        });\n        if (responsePromise) {\n          event.respondWith(responsePromise);\n        }\n      });\n    }\n    /**\r\n     * Adds a message event listener for URLs to cache from the window.\r\n     * This is useful to cache resources loaded on the page prior to when the\r\n     * service worker started controlling it.\r\n     *\r\n     * The format of the message data sent from the window should be as follows.\r\n     * Where the `urlsToCache` array may consist of URL strings or an array of\r\n     * URL string + `requestInit` object (the same as you'd pass to `fetch()`).\r\n     *\r\n     * ```\r\n     * {\r\n     *   type: 'CACHE_URLS',\r\n     *   payload: {\r\n     *     urlsToCache: [\r\n     *       './script1.js',\r\n     *       './script2.js',\r\n     *       ['./script3.js', {mode: 'no-cors'}],\r\n     *     ],\r\n     *   },\r\n     * }\r\n     * ```\r\n     */\n  }, {\n    key: \"addCacheListener\",\n    value: function addCacheListener() {\n      var _this2 = this;\n      // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n      self.addEventListener('message', function (event) {\n        // event.data is type 'any'\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        if (event.data && event.data.type === 'CACHE_URLS') {\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n          var payload = event.data.payload;\n          if (process.env.NODE_ENV !== 'production') {\n            logger.debug(\"Caching URLs from the window\", payload.urlsToCache);\n          }\n          var requestPromises = Promise.all(payload.urlsToCache.map(function (entry) {\n            if (typeof entry === 'string') {\n              entry = [entry];\n            }\n            var request = _construct(Request, _toConsumableArray(entry));\n            return _this2.handleRequest({\n              request: request,\n              event: event\n            });\n            // TODO(philipwalton): TypeScript errors without this typecast for\n            // some reason (probably a bug). The real type here should work but\n            // doesn't: `Array<Promise<Response> | undefined>`.\n          })); // TypeScript\n          event.waitUntil(requestPromises);\n          // If a MessageChannel was used, reply to the message on success.\n          if (event.ports && event.ports[0]) {\n            void requestPromises.then(function () {\n              return event.ports[0].postMessage(true);\n            });\n          }\n        }\n      });\n    }\n    /**\r\n     * Apply the routing rules to a FetchEvent object to get a Response from an\r\n     * appropriate Route's handler.\r\n     *\r\n     * @param {Object} options\r\n     * @param {Request} options.request The request to handle.\r\n     * @param {ExtendableEvent} options.event The event that triggered the\r\n     *     request.\r\n     * @return {Promise<Response>|undefined} A promise is returned if a\r\n     *     registered route can handle the request. If there is no matching\r\n     *     route and there's no `defaultHandler`, `undefined` is returned.\r\n     */\n  }, {\n    key: \"handleRequest\",\n    value: function handleRequest(_ref) {\n      var _this3 = this;\n      var request = _ref.request,\n        event = _ref.event;\n      if (process.env.NODE_ENV !== 'production') {\n        assert.isInstance(request, Request, {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'handleRequest',\n          paramName: 'options.request'\n        });\n      }\n      var url = new URL(request.url, location.href);\n      if (!url.protocol.startsWith('http')) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.debug(\"Workbox Router only supports URLs that start with 'http'.\");\n        }\n        return;\n      }\n      var sameOrigin = url.origin === location.origin;\n      var _this$findMatchingRou = this.findMatchingRoute({\n          event: event,\n          request: request,\n          sameOrigin: sameOrigin,\n          url: url\n        }),\n        params = _this$findMatchingRou.params,\n        route = _this$findMatchingRou.route;\n      var handler = route && route.handler;\n      var debugMessages = [];\n      if (process.env.NODE_ENV !== 'production') {\n        if (handler) {\n          debugMessages.push([\"Found a route to handle this request:\", route]);\n          if (params) {\n            debugMessages.push([\"Passing the following params to the route's handler:\", params]);\n          }\n        }\n      }\n      // If we don't have a handler because there was no matching route, then\n      // fall back to defaultHandler if that's defined.\n      var method = request.method;\n      if (!handler && this._defaultHandlerMap.has(method)) {\n        if (process.env.NODE_ENV !== 'production') {\n          debugMessages.push(\"Failed to find a matching route. Falling \" + \"back to the default handler for \".concat(method, \".\"));\n        }\n        handler = this._defaultHandlerMap.get(method);\n      }\n      if (!handler) {\n        if (process.env.NODE_ENV !== 'production') {\n          // No handler so Workbox will do nothing. If logs is set of debug\n          // i.e. verbose, we should print out this information.\n          logger.debug(\"No route found for: \".concat(getFriendlyURL(url)));\n        }\n        return;\n      }\n      if (process.env.NODE_ENV !== 'production') {\n        // We have a handler, meaning Workbox is going to handle the route.\n        // print the routing details to the console.\n        logger.groupCollapsed(\"Router is responding to: \".concat(getFriendlyURL(url)));\n        debugMessages.forEach(function (msg) {\n          if (Array.isArray(msg)) {\n            logger.log.apply(logger, _toConsumableArray(msg));\n          } else {\n            logger.log(msg);\n          }\n        });\n        logger.groupEnd();\n      }\n      // Wrap in try and catch in case the handle method throws a synchronous\n      // error. It should still callback to the catch handler.\n      var responsePromise;\n      try {\n        responsePromise = handler.handle({\n          url: url,\n          request: request,\n          event: event,\n          params: params\n        });\n      } catch (err) {\n        responsePromise = Promise.reject(err);\n      }\n      // Get route's catch handler, if it exists\n      var catchHandler = route && route.catchHandler;\n      if (responsePromise instanceof Promise && (this._catchHandler || catchHandler)) {\n        responsePromise = responsePromise.catch( /*#__PURE__*/function () {\n          var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(err) {\n            return _regeneratorRuntime().wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  if (!catchHandler) {\n                    _context.next = 11;\n                    break;\n                  }\n                  if (process.env.NODE_ENV !== 'production') {\n                    // Still include URL here as it will be async from the console group\n                    // and may not make sense without the URL\n                    logger.groupCollapsed(\"Error thrown when responding to: \" + \" \".concat(getFriendlyURL(url), \". Falling back to route's Catch Handler.\"));\n                    logger.error(\"Error thrown by:\", route);\n                    logger.error(err);\n                    logger.groupEnd();\n                  }\n                  _context.prev = 2;\n                  _context.next = 5;\n                  return catchHandler.handle({\n                    url: url,\n                    request: request,\n                    event: event,\n                    params: params\n                  });\n                case 5:\n                  return _context.abrupt(\"return\", _context.sent);\n                case 8:\n                  _context.prev = 8;\n                  _context.t0 = _context[\"catch\"](2);\n                  if (_context.t0 instanceof Error) {\n                    err = _context.t0;\n                  }\n                case 11:\n                  if (!_this3._catchHandler) {\n                    _context.next = 14;\n                    break;\n                  }\n                  if (process.env.NODE_ENV !== 'production') {\n                    // Still include URL here as it will be async from the console group\n                    // and may not make sense without the URL\n                    logger.groupCollapsed(\"Error thrown when responding to: \" + \" \".concat(getFriendlyURL(url), \". Falling back to global Catch Handler.\"));\n                    logger.error(\"Error thrown by:\", route);\n                    logger.error(err);\n                    logger.groupEnd();\n                  }\n                  return _context.abrupt(\"return\", _this3._catchHandler.handle({\n                    url: url,\n                    request: request,\n                    event: event\n                  }));\n                case 14:\n                  throw err;\n                case 15:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee, null, [[2, 8]]);\n          }));\n          return function (_x) {\n            return _ref2.apply(this, arguments);\n          };\n        }());\n      }\n      return responsePromise;\n    }\n    /**\r\n     * Checks a request and URL (and optionally an event) against the list of\r\n     * registered routes, and if there's a match, returns the corresponding\r\n     * route along with any params generated by the match.\r\n     *\r\n     * @param {Object} options\r\n     * @param {URL} options.url\r\n     * @param {boolean} options.sameOrigin The result of comparing `url.origin`\r\n     *     against the current origin.\r\n     * @param {Request} options.request The request to match.\r\n     * @param {Event} options.event The corresponding event.\r\n     * @return {Object} An object with `route` and `params` properties.\r\n     *     They are populated if a matching route was found or `undefined`\r\n     *     otherwise.\r\n     */\n  }, {\n    key: \"findMatchingRoute\",\n    value: function findMatchingRoute(_ref3) {\n      var url = _ref3.url,\n        sameOrigin = _ref3.sameOrigin,\n        request = _ref3.request,\n        event = _ref3.event;\n      var routes = this._routes.get(request.method) || [];\n      var _iterator = _createForOfIteratorHelper(routes),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var route = _step.value;\n          var params = void 0;\n          // route.match returns type any, not possible to change right now.\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n          var matchResult = route.match({\n            url: url,\n            sameOrigin: sameOrigin,\n            request: request,\n            event: event\n          });\n          if (matchResult) {\n            if (process.env.NODE_ENV !== 'production') {\n              // Warn developers that using an async matchCallback is almost always\n              // not the right thing to do.\n              if (matchResult instanceof Promise) {\n                logger.warn(\"While routing \".concat(getFriendlyURL(url), \", an async \") + \"matchCallback function was used. Please convert the \" + \"following route to use a synchronous matchCallback function:\", route);\n              }\n            }\n            // See https://github.com/GoogleChrome/workbox/issues/2079\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            params = matchResult;\n            if (Array.isArray(params) && params.length === 0) {\n              // Instead of passing an empty array in as params, use undefined.\n              params = undefined;\n            } else if (matchResult.constructor === Object &&\n            // eslint-disable-line\n            Object.keys(matchResult).length === 0) {\n              // Instead of passing an empty object in as params, use undefined.\n              params = undefined;\n            } else if (typeof matchResult === 'boolean') {\n              // For the boolean value true (rather than just something truth-y),\n              // don't set params.\n              // See https://github.com/GoogleChrome/workbox/pull/2134#issuecomment-513924353\n              params = undefined;\n            }\n            // Return early if have a match.\n            return {\n              route: route,\n              params: params\n            };\n          }\n        }\n        // If no match was found above, return and empty object.\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return {};\n    }\n    /**\r\n     * Define a default `handler` that's called when no routes explicitly\r\n     * match the incoming request.\r\n     *\r\n     * Each HTTP method ('GET', 'POST', etc.) gets its own default handler.\r\n     *\r\n     * Without a default handler, unmatched requests will go against the\r\n     * network as if there were no service worker present.\r\n     *\r\n     * @param {workbox-routing~handlerCallback} handler A callback\r\n     * function that returns a Promise resulting in a Response.\r\n     * @param {string} [method='GET'] The HTTP method to associate with this\r\n     * default handler. Each method has its own default.\r\n     */\n  }, {\n    key: \"setDefaultHandler\",\n    value: function setDefaultHandler(handler) {\n      var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultMethod;\n      this._defaultHandlerMap.set(method, normalizeHandler(handler));\n    }\n    /**\r\n     * If a Route throws an error while handling a request, this `handler`\r\n     * will be called and given a chance to provide a response.\r\n     *\r\n     * @param {workbox-routing~handlerCallback} handler A callback\r\n     * function that returns a Promise resulting in a Response.\r\n     */\n  }, {\n    key: \"setCatchHandler\",\n    value: function setCatchHandler(handler) {\n      this._catchHandler = normalizeHandler(handler);\n    }\n    /**\r\n     * Registers a route with the router.\r\n     *\r\n     * @param {workbox-routing.Route} route The route to register.\r\n     */\n  }, {\n    key: \"registerRoute\",\n    value: function registerRoute(route) {\n      if (process.env.NODE_ENV !== 'production') {\n        assert.isType(route, 'object', {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'registerRoute',\n          paramName: 'route'\n        });\n        assert.hasMethod(route, 'match', {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'registerRoute',\n          paramName: 'route'\n        });\n        assert.isType(route.handler, 'object', {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'registerRoute',\n          paramName: 'route'\n        });\n        assert.hasMethod(route.handler, 'handle', {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'registerRoute',\n          paramName: 'route.handler'\n        });\n        assert.isType(route.method, 'string', {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'registerRoute',\n          paramName: 'route.method'\n        });\n      }\n      if (!this._routes.has(route.method)) {\n        this._routes.set(route.method, []);\n      }\n      // Give precedence to all of the earlier routes by adding this additional\n      // route to the end of the array.\n      this._routes.get(route.method).push(route);\n    }\n    /**\r\n     * Unregisters a route with the router.\r\n     *\r\n     * @param {workbox-routing.Route} route The route to unregister.\r\n     */\n  }, {\n    key: \"unregisterRoute\",\n    value: function unregisterRoute(route) {\n      if (!this._routes.has(route.method)) {\n        throw new WorkboxError('unregister-route-but-not-found-with-method', {\n          method: route.method\n        });\n      }\n      var routeIndex = this._routes.get(route.method).indexOf(route);\n      if (routeIndex > -1) {\n        this._routes.get(route.method).splice(routeIndex, 1);\n      } else {\n        throw new WorkboxError('unregister-route-route-not-registered');\n      }\n    }\n  }]);\n  return Router;\n}();\nexport { Router };","map":{"version":3,"names":["assert","getFriendlyURL","defaultMethod","logger","normalizeHandler","WorkboxError","Router","_routes","Map","_defaultHandlerMap","self","addEventListener","event","request","responsePromise","handleRequest","respondWith","data","type","payload","process","env","NODE_ENV","debug","urlsToCache","requestPromises","Promise","all","map","entry","Request","waitUntil","ports","then","postMessage","isInstance","moduleName","className","funcName","paramName","url","URL","location","href","protocol","startsWith","sameOrigin","origin","findMatchingRoute","params","route","handler","debugMessages","push","method","has","get","groupCollapsed","forEach","msg","Array","isArray","log","groupEnd","handle","err","reject","catchHandler","_catchHandler","catch","error","Error","routes","matchResult","match","warn","length","undefined","constructor","Object","keys","set","isType","hasMethod","routeIndex","indexOf","splice"],"sources":["D:/github/music-pwa-frontend/node_modules/workbox-routing/Router.js"],"sourcesContent":["/*\r\n  Copyright 2018 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { assert } from 'workbox-core/_private/assert.js';\r\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\r\nimport { defaultMethod } from './utils/constants.js';\r\nimport { logger } from 'workbox-core/_private/logger.js';\r\nimport { normalizeHandler } from './utils/normalizeHandler.js';\r\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\r\nimport './_version.js';\r\n/**\r\n * The Router can be used to process a `FetchEvent` using one or more\r\n * {@link workbox-routing.Route}, responding with a `Response` if\r\n * a matching route exists.\r\n *\r\n * If no route matches a given a request, the Router will use a \"default\"\r\n * handler if one is defined.\r\n *\r\n * Should the matching Route throw an error, the Router will use a \"catch\"\r\n * handler if one is defined to gracefully deal with issues and respond with a\r\n * Request.\r\n *\r\n * If a request matches multiple routes, the **earliest** registered route will\r\n * be used to respond to the request.\r\n *\r\n * @memberof workbox-routing\r\n */\r\nclass Router {\r\n    /**\r\n     * Initializes a new Router.\r\n     */\r\n    constructor() {\r\n        this._routes = new Map();\r\n        this._defaultHandlerMap = new Map();\r\n    }\r\n    /**\r\n     * @return {Map<string, Array<workbox-routing.Route>>} routes A `Map` of HTTP\r\n     * method name ('GET', etc.) to an array of all the corresponding `Route`\r\n     * instances that are registered.\r\n     */\r\n    get routes() {\r\n        return this._routes;\r\n    }\r\n    /**\r\n     * Adds a fetch event listener to respond to events when a route matches\r\n     * the event's request.\r\n     */\r\n    addFetchListener() {\r\n        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\r\n        self.addEventListener('fetch', ((event) => {\r\n            const { request } = event;\r\n            const responsePromise = this.handleRequest({ request, event });\r\n            if (responsePromise) {\r\n                event.respondWith(responsePromise);\r\n            }\r\n        }));\r\n    }\r\n    /**\r\n     * Adds a message event listener for URLs to cache from the window.\r\n     * This is useful to cache resources loaded on the page prior to when the\r\n     * service worker started controlling it.\r\n     *\r\n     * The format of the message data sent from the window should be as follows.\r\n     * Where the `urlsToCache` array may consist of URL strings or an array of\r\n     * URL string + `requestInit` object (the same as you'd pass to `fetch()`).\r\n     *\r\n     * ```\r\n     * {\r\n     *   type: 'CACHE_URLS',\r\n     *   payload: {\r\n     *     urlsToCache: [\r\n     *       './script1.js',\r\n     *       './script2.js',\r\n     *       ['./script3.js', {mode: 'no-cors'}],\r\n     *     ],\r\n     *   },\r\n     * }\r\n     * ```\r\n     */\r\n    addCacheListener() {\r\n        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\r\n        self.addEventListener('message', ((event) => {\r\n            // event.data is type 'any'\r\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\r\n            if (event.data && event.data.type === 'CACHE_URLS') {\r\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\r\n                const { payload } = event.data;\r\n                if (process.env.NODE_ENV !== 'production') {\r\n                    logger.debug(`Caching URLs from the window`, payload.urlsToCache);\r\n                }\r\n                const requestPromises = Promise.all(payload.urlsToCache.map((entry) => {\r\n                    if (typeof entry === 'string') {\r\n                        entry = [entry];\r\n                    }\r\n                    const request = new Request(...entry);\r\n                    return this.handleRequest({ request, event });\r\n                    // TODO(philipwalton): TypeScript errors without this typecast for\r\n                    // some reason (probably a bug). The real type here should work but\r\n                    // doesn't: `Array<Promise<Response> | undefined>`.\r\n                })); // TypeScript\r\n                event.waitUntil(requestPromises);\r\n                // If a MessageChannel was used, reply to the message on success.\r\n                if (event.ports && event.ports[0]) {\r\n                    void requestPromises.then(() => event.ports[0].postMessage(true));\r\n                }\r\n            }\r\n        }));\r\n    }\r\n    /**\r\n     * Apply the routing rules to a FetchEvent object to get a Response from an\r\n     * appropriate Route's handler.\r\n     *\r\n     * @param {Object} options\r\n     * @param {Request} options.request The request to handle.\r\n     * @param {ExtendableEvent} options.event The event that triggered the\r\n     *     request.\r\n     * @return {Promise<Response>|undefined} A promise is returned if a\r\n     *     registered route can handle the request. If there is no matching\r\n     *     route and there's no `defaultHandler`, `undefined` is returned.\r\n     */\r\n    handleRequest({ request, event, }) {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            assert.isInstance(request, Request, {\r\n                moduleName: 'workbox-routing',\r\n                className: 'Router',\r\n                funcName: 'handleRequest',\r\n                paramName: 'options.request',\r\n            });\r\n        }\r\n        const url = new URL(request.url, location.href);\r\n        if (!url.protocol.startsWith('http')) {\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                logger.debug(`Workbox Router only supports URLs that start with 'http'.`);\r\n            }\r\n            return;\r\n        }\r\n        const sameOrigin = url.origin === location.origin;\r\n        const { params, route } = this.findMatchingRoute({\r\n            event,\r\n            request,\r\n            sameOrigin,\r\n            url,\r\n        });\r\n        let handler = route && route.handler;\r\n        const debugMessages = [];\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (handler) {\r\n                debugMessages.push([`Found a route to handle this request:`, route]);\r\n                if (params) {\r\n                    debugMessages.push([\r\n                        `Passing the following params to the route's handler:`,\r\n                        params,\r\n                    ]);\r\n                }\r\n            }\r\n        }\r\n        // If we don't have a handler because there was no matching route, then\r\n        // fall back to defaultHandler if that's defined.\r\n        const method = request.method;\r\n        if (!handler && this._defaultHandlerMap.has(method)) {\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                debugMessages.push(`Failed to find a matching route. Falling ` +\r\n                    `back to the default handler for ${method}.`);\r\n            }\r\n            handler = this._defaultHandlerMap.get(method);\r\n        }\r\n        if (!handler) {\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                // No handler so Workbox will do nothing. If logs is set of debug\r\n                // i.e. verbose, we should print out this information.\r\n                logger.debug(`No route found for: ${getFriendlyURL(url)}`);\r\n            }\r\n            return;\r\n        }\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            // We have a handler, meaning Workbox is going to handle the route.\r\n            // print the routing details to the console.\r\n            logger.groupCollapsed(`Router is responding to: ${getFriendlyURL(url)}`);\r\n            debugMessages.forEach((msg) => {\r\n                if (Array.isArray(msg)) {\r\n                    logger.log(...msg);\r\n                }\r\n                else {\r\n                    logger.log(msg);\r\n                }\r\n            });\r\n            logger.groupEnd();\r\n        }\r\n        // Wrap in try and catch in case the handle method throws a synchronous\r\n        // error. It should still callback to the catch handler.\r\n        let responsePromise;\r\n        try {\r\n            responsePromise = handler.handle({ url, request, event, params });\r\n        }\r\n        catch (err) {\r\n            responsePromise = Promise.reject(err);\r\n        }\r\n        // Get route's catch handler, if it exists\r\n        const catchHandler = route && route.catchHandler;\r\n        if (responsePromise instanceof Promise &&\r\n            (this._catchHandler || catchHandler)) {\r\n            responsePromise = responsePromise.catch(async (err) => {\r\n                // If there's a route catch handler, process that first\r\n                if (catchHandler) {\r\n                    if (process.env.NODE_ENV !== 'production') {\r\n                        // Still include URL here as it will be async from the console group\r\n                        // and may not make sense without the URL\r\n                        logger.groupCollapsed(`Error thrown when responding to: ` +\r\n                            ` ${getFriendlyURL(url)}. Falling back to route's Catch Handler.`);\r\n                        logger.error(`Error thrown by:`, route);\r\n                        logger.error(err);\r\n                        logger.groupEnd();\r\n                    }\r\n                    try {\r\n                        return await catchHandler.handle({ url, request, event, params });\r\n                    }\r\n                    catch (catchErr) {\r\n                        if (catchErr instanceof Error) {\r\n                            err = catchErr;\r\n                        }\r\n                    }\r\n                }\r\n                if (this._catchHandler) {\r\n                    if (process.env.NODE_ENV !== 'production') {\r\n                        // Still include URL here as it will be async from the console group\r\n                        // and may not make sense without the URL\r\n                        logger.groupCollapsed(`Error thrown when responding to: ` +\r\n                            ` ${getFriendlyURL(url)}. Falling back to global Catch Handler.`);\r\n                        logger.error(`Error thrown by:`, route);\r\n                        logger.error(err);\r\n                        logger.groupEnd();\r\n                    }\r\n                    return this._catchHandler.handle({ url, request, event });\r\n                }\r\n                throw err;\r\n            });\r\n        }\r\n        return responsePromise;\r\n    }\r\n    /**\r\n     * Checks a request and URL (and optionally an event) against the list of\r\n     * registered routes, and if there's a match, returns the corresponding\r\n     * route along with any params generated by the match.\r\n     *\r\n     * @param {Object} options\r\n     * @param {URL} options.url\r\n     * @param {boolean} options.sameOrigin The result of comparing `url.origin`\r\n     *     against the current origin.\r\n     * @param {Request} options.request The request to match.\r\n     * @param {Event} options.event The corresponding event.\r\n     * @return {Object} An object with `route` and `params` properties.\r\n     *     They are populated if a matching route was found or `undefined`\r\n     *     otherwise.\r\n     */\r\n    findMatchingRoute({ url, sameOrigin, request, event, }) {\r\n        const routes = this._routes.get(request.method) || [];\r\n        for (const route of routes) {\r\n            let params;\r\n            // route.match returns type any, not possible to change right now.\r\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\r\n            const matchResult = route.match({ url, sameOrigin, request, event });\r\n            if (matchResult) {\r\n                if (process.env.NODE_ENV !== 'production') {\r\n                    // Warn developers that using an async matchCallback is almost always\r\n                    // not the right thing to do.\r\n                    if (matchResult instanceof Promise) {\r\n                        logger.warn(`While routing ${getFriendlyURL(url)}, an async ` +\r\n                            `matchCallback function was used. Please convert the ` +\r\n                            `following route to use a synchronous matchCallback function:`, route);\r\n                    }\r\n                }\r\n                // See https://github.com/GoogleChrome/workbox/issues/2079\r\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\r\n                params = matchResult;\r\n                if (Array.isArray(params) && params.length === 0) {\r\n                    // Instead of passing an empty array in as params, use undefined.\r\n                    params = undefined;\r\n                }\r\n                else if (matchResult.constructor === Object && // eslint-disable-line\r\n                    Object.keys(matchResult).length === 0) {\r\n                    // Instead of passing an empty object in as params, use undefined.\r\n                    params = undefined;\r\n                }\r\n                else if (typeof matchResult === 'boolean') {\r\n                    // For the boolean value true (rather than just something truth-y),\r\n                    // don't set params.\r\n                    // See https://github.com/GoogleChrome/workbox/pull/2134#issuecomment-513924353\r\n                    params = undefined;\r\n                }\r\n                // Return early if have a match.\r\n                return { route, params };\r\n            }\r\n        }\r\n        // If no match was found above, return and empty object.\r\n        return {};\r\n    }\r\n    /**\r\n     * Define a default `handler` that's called when no routes explicitly\r\n     * match the incoming request.\r\n     *\r\n     * Each HTTP method ('GET', 'POST', etc.) gets its own default handler.\r\n     *\r\n     * Without a default handler, unmatched requests will go against the\r\n     * network as if there were no service worker present.\r\n     *\r\n     * @param {workbox-routing~handlerCallback} handler A callback\r\n     * function that returns a Promise resulting in a Response.\r\n     * @param {string} [method='GET'] The HTTP method to associate with this\r\n     * default handler. Each method has its own default.\r\n     */\r\n    setDefaultHandler(handler, method = defaultMethod) {\r\n        this._defaultHandlerMap.set(method, normalizeHandler(handler));\r\n    }\r\n    /**\r\n     * If a Route throws an error while handling a request, this `handler`\r\n     * will be called and given a chance to provide a response.\r\n     *\r\n     * @param {workbox-routing~handlerCallback} handler A callback\r\n     * function that returns a Promise resulting in a Response.\r\n     */\r\n    setCatchHandler(handler) {\r\n        this._catchHandler = normalizeHandler(handler);\r\n    }\r\n    /**\r\n     * Registers a route with the router.\r\n     *\r\n     * @param {workbox-routing.Route} route The route to register.\r\n     */\r\n    registerRoute(route) {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            assert.isType(route, 'object', {\r\n                moduleName: 'workbox-routing',\r\n                className: 'Router',\r\n                funcName: 'registerRoute',\r\n                paramName: 'route',\r\n            });\r\n            assert.hasMethod(route, 'match', {\r\n                moduleName: 'workbox-routing',\r\n                className: 'Router',\r\n                funcName: 'registerRoute',\r\n                paramName: 'route',\r\n            });\r\n            assert.isType(route.handler, 'object', {\r\n                moduleName: 'workbox-routing',\r\n                className: 'Router',\r\n                funcName: 'registerRoute',\r\n                paramName: 'route',\r\n            });\r\n            assert.hasMethod(route.handler, 'handle', {\r\n                moduleName: 'workbox-routing',\r\n                className: 'Router',\r\n                funcName: 'registerRoute',\r\n                paramName: 'route.handler',\r\n            });\r\n            assert.isType(route.method, 'string', {\r\n                moduleName: 'workbox-routing',\r\n                className: 'Router',\r\n                funcName: 'registerRoute',\r\n                paramName: 'route.method',\r\n            });\r\n        }\r\n        if (!this._routes.has(route.method)) {\r\n            this._routes.set(route.method, []);\r\n        }\r\n        // Give precedence to all of the earlier routes by adding this additional\r\n        // route to the end of the array.\r\n        this._routes.get(route.method).push(route);\r\n    }\r\n    /**\r\n     * Unregisters a route with the router.\r\n     *\r\n     * @param {workbox-routing.Route} route The route to unregister.\r\n     */\r\n    unregisterRoute(route) {\r\n        if (!this._routes.has(route.method)) {\r\n            throw new WorkboxError('unregister-route-but-not-found-with-method', {\r\n                method: route.method,\r\n            });\r\n        }\r\n        const routeIndex = this._routes.get(route.method).indexOf(route);\r\n        if (routeIndex > -1) {\r\n            this._routes.get(route.method).splice(routeIndex, 1);\r\n        }\r\n        else {\r\n            throw new WorkboxError('unregister-route-route-not-registered');\r\n        }\r\n    }\r\n}\r\nexport { Router };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}